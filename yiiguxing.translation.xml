<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="526" />
    <option name="newTranslationDialogX" value="773" />
    <option name="newTranslationDialogY" value="663" />
    <histories>
      <item value="Register the given native Caffeine Cache instance with this cache manager, adapting it to Spring's cache API for exposure through {@link getCache}. Any number of such custom caches may be registered side by side. &lt;p&gt;This allows for custom settings per cache (as opposed to all caches sharing the common settings in the cache manager's configuration) and is typically used with the Caffeine builder API: {@code registerCustomCache(&quot;myCache&quot;, Caffeine.newBuilder().maximumSize(10).build())} &lt;p&gt;Note that any other caches, whether statically specified through {@link setCacheNames} or dynamically built on demand, still operate with the common settings in the cache manager's configuration." />
      <item value="Set the Caffeine to use for building each individual" />
      <item value="Construct a static CaffeineCacheManager, managing caches for the specified cache names only." />
      <item value="Set the Caffeine cache specification String to use for building each individual {@link CaffeineCache} instance. The given value needs to comply with Caffeine's {@link CaffeineSpec} (see its javadoc)." />
      <item value="Whether all the entries inside the cache(s) are removed. &lt;p&gt;By default, only the value under the associated key is removed. &lt;p&gt;Note that setting this parameter to {@code true} and specifying a {@link key} is not allowed." />
      <item value="分离" />
      <item value="f" />
      <item value="额外" />
      <item value="Burry" />
      <item value="A container for settings for the generation of getters and setters. &lt;p&gt; Complete documentation is found at &lt;a href=&quot;https:projectlombok.orgfeaturesexperimentalAccessors&quot;&gt;the project lombok features page for &amp;64;Accessors&lt;a&gt;. &lt;p&gt; Using this annotation does nothing by itself; an annotation that makes lombok generate getters and setters, such as {@link lombok.Setter} or {@link lombok.Data} is also required." />
      <item value="Use {@code var} as the type of any local variable declaration (even in a {@code for} statement), and the type will be inferred from the initializing expression (any further assignments to the variable are not involved in this type inference). &lt;p&gt; For example: {@code var x = 10.0;} will infer {@code double}, and {@code var y = new ArrayList&lt;String&gt;();} will infer {@code ArrayList&lt;String&gt;}. &lt;p&gt; Note that this is an annotation type because {@code var x = 10;} will be desugared to {@code @var int x = 10;} &lt;p&gt; Complete documentation is found at &lt;a href=&quot;https:projectlombok.orgfeaturesvar&quot;&gt;the project lombok features page for &amp;64;var&lt;a&gt;." />
      <item value="Lombok will eventually automatically add this annotation to all generated constructors, methods, fields, and types. You can mark the presence of this annotation as 'ignore it' for all code style and bug finding tools. &lt;p&gt; NB: As of v1.16.2 which introduces this annotation, lombok doesn't actually add this annotation; we're setting it up so that lombok jars in widespread use start having this, which will make it easier to actually apply it later on. By adding {@code lombok.addLombokGeneratedAnnotation = true} to {@code lombok.config} you can already get this behavior." />
      <item value="Eagerly load the NestedExceptionUtils class to avoid classloader deadlock issues on OSGi when calling getMessage(). Reported by Don Brown; SPR-5607." />
      <item value="struction" />
      <item value="str" />
      <item value="stur" />
      <item value="sr" />
      <item value="Should be used at package level in association with {@link Nullable} annotations at parameter and return value level." />
      <item value="Malformed argument has embedded quote: -Djava.endorsed.dirs=\&quot;\&quot;" />
      <item value="Default typically equals {@link NO}, unless a different default has been configured at the component-scan instruction level." />
      <item value="Configure the behaviour of how this member is treated in the {@code equals} and {@code hashCode} implementation; if on a method, include the method's return value as part of calculating hashCodeequality." />
      <item value="@return If {@code true}, always use direct field access instead of calling the getter method." />
      <item value="Normally, if getters are available, those are called. To suppress this and let the generated code use the fields directly, set this to {@code true}." />
      <item value="Will soon be marked {@code @Deprecated}; use the {@code @EqualsAndHashCode.Include} annotation together with {@code @EqualsAndHashCode(onlyExplicitlyIncluded = true)}." />
      <item value="Inspection" />
      <item value="DTO for presenting and selecting an itinerary from a collection of candidates." />
      <item value="Can also be used with method level validation, indicating that a specific class is supposed to be validated at the method level (acting as a pointcut for the corresponding validation interceptor), but also optionally specifying the validation groups for method-level validation in the annotated class. Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with. Can also be used as a meta-annotation on a custom stereotype annotation or a custom group-specific validated annotation." />
      <item value="Variant of JSR-303's {@link javax.validation.Valid}, supporting the specification of validation groups. Designed for convenient use with Spring's JSR-303 support but not JSR-303 specific. &lt;p&gt;Can be used e.g. with Spring MVC handler methods arguments. Supported through {@link org.springframework.validation.SmartValidator}'s validation hint concept, with validation group classes acting as hint objects. &lt;p&gt;Can also be used with method level validation, indicating that a specific class is supposed to be validated at the method level (acting as a pointcut for the corresponding validation interceptor), but also optionally specifying the validation groups for method-level validation in the annotated class. Applying this annotation at the method level allows for overriding the validation groups for a specific method but does not serve as a pointcut; a class-level annotation is nevertheless necessary to trigger method validation for a specific bean to begin with. Can also be used as a meta-annotation on a custom stereotype annotation or a custom group-specific validated annotation." />
      <item value="Variant" />
      <item value="Asserts that the annotated string, collection, map or array is not {@code null} or empty." />
      <item value="Validate that the annotated string is not {@code null} or empty. The difference to {@code NotEmpty} is that trailing whitespaces are getting ignored." />
      <item value="邀请者" />
      <item value="newly" />
      <item value="new " />
      <item value="Thaw" />
      <item value="delimiter" />
      <item value="This inspection only reports when the suggested replacement does not result in significant performance drawback on modern JVMs. In many cases the String concatenation may perform better." />
      <item value="裂变红包" />
      <item value="裂变" />
      <item value="分裂" />
      <item value="count By FromOpenId" />
      <item value="count ByFromOpenId" />
      <item value="count B yFromOpenId" />
      <item value="countByFromOpenId" />
      <item value="fromOpenId" />
      <item value="invitePlayer" />
      <item value="invitedPlayer" />
      <item value="locale" />
      <item value="Handles cargo booking and routing. Operates against a dedicated remoting service facade, and could easily be rewritten as a thick Swing client. Completely separated from the domain layer, unlike the tracking user interface. &lt;p&gt; In order to successfully keep the domain model shielded from user interface considerations, this approach is generally preferred to the one taken in the tracking controller. However, there is never any one perfect solution for all situations, so we've chosen to demonstrate two polarized ways to build user interfaces." />
      <item value="dedicated" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="360" />
        <entry key="ENGLISH" value="361" />
        <entry key="GERMAN" value="2" />
        <entry key="FRENCH" value="1" />
        <entry key="GUJARATI" value="1" />
        <entry key="GALICIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1628476573216" />
  </component>
</application>