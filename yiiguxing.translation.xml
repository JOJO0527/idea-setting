<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="548" />
    <option name="newTranslationDialogX" value="773" />
    <option name="newTranslationDialogY" value="663" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="compatible with the accumulator function" />
      <item value="associative" />
      <item value="equivalent" />
      <item value="unmodifiable" />
      <item value="Rewinds this buffer" />
      <item value="underlying" />
      <item value="Coyote" />
      <item value="resolve" />
      <item value="sercet" />
      <item value="discard" />
      <item value="discar" />
      <item value="dis" />
      <item value="Write Off" />
      <item value="Legal" />
      <item value="relative" />
      <item value="incompatible" />
      <item value="incom" />
      <item value="ware" />
      <item value="wareOrder&#10;" />
      <item value="wareOrder" />
      <item value="delimiter" />
      <item value="搬运&#10;" />
      <item value="关系&#10;" />
      <item value="关系" />
      <item value="evaluated" />
      <item value="核销" />
      <item value="reduant" />
      <item value="redu" />
      <item value="fluent" />
      <item value="以下" />
      <item value="attachment" />
      <item value="&lt;p&gt;The returned map preserves the order of the entries from" />
      <item value="The command is exactly equivalent to the following group of commands:" />
      <item value="Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly." />
      <item value="Enqueued" />
      <item value="Treated specially by GC" />
      <item value="Treated" />
      <item value="In either case" />
      <item value="saturated" />
      <item value="A bounded queue (for example, an {@link ArrayBlockingQueue}) helps prevent resource exhaustion when used with finite maximumPoolSizes, but can be more difficult to tune and control. Queue sizes and maximum pool sizes may be traded off for each other: Using large queues and small pools minimizes CPU usage, OS resources, and context-switching overhead, but can lead to artificially low throughput. If tasks frequently block (for example if they are IO bound), a system may be able to schedule time for more threads than you otherwise allow. Use of small queues generally requires larger pool sizes, which keeps CPUs busier but may encounter unacceptable scheduling overhead, which also decreases throughput." />
      <item value="otherwise" />
      <item value="artificially" />
      <item value="traded off" />
      <item value="tune" />
      <item value="but can be more difficult to tune and control" />
      <item value="finite" />
      <item value="exhaustion" />
      <item value="appropriate" />
      <item value="average" />
      <item value="This may be appropriate when each task is completely independent of others, so tasks cannot affect each others execution; for example, in a web page server. While this style of queuing can be useful in smoothing out transient bursts of requests, it admits the possibility of unbounded work queue growth when commands continue to arrive on average faster than they can be processed." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="266" />
        <entry key="ENGLISH" value="267" />
        <entry key="GERMAN" value="2" />
        <entry key="GUJARATI" value="1" />
        <entry key="GALICIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1622441109525" />
  </component>
</application>