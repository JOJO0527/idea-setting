<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="550" />
    <option name="newTranslationDialogX" value="773" />
    <option name="newTranslationDialogY" value="663" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="fluent" />
      <item value="以下" />
      <item value="attachment" />
      <item value="&lt;p&gt;The returned map preserves the order of the entries from" />
      <item value="The command is exactly equivalent to the following group of commands:" />
      <item value="Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly." />
      <item value="Enqueued" />
      <item value="Treated specially by GC" />
      <item value="Treated" />
      <item value="In either case" />
      <item value="saturated" />
      <item value="A bounded queue (for example, an {@link ArrayBlockingQueue}) helps prevent resource exhaustion when used with finite maximumPoolSizes, but can be more difficult to tune and control. Queue sizes and maximum pool sizes may be traded off for each other: Using large queues and small pools minimizes CPU usage, OS resources, and context-switching overhead, but can lead to artificially low throughput. If tasks frequently block (for example if they are IO bound), a system may be able to schedule time for more threads than you otherwise allow. Use of small queues generally requires larger pool sizes, which keeps CPUs busier but may encounter unacceptable scheduling overhead, which also decreases throughput." />
      <item value="otherwise" />
      <item value="artificially" />
      <item value="traded off" />
      <item value="tune" />
      <item value="but can be more difficult to tune and control" />
      <item value="finite" />
      <item value="exhaustion" />
      <item value="appropriate" />
      <item value="average" />
      <item value="This may be appropriate when each task is completely independent of others, so tasks cannot affect each others execution; for example, in a web page server. While this style of queuing can be useful in smoothing out transient bursts of requests, it admits the possibility of unbounded work queue growth when commands continue to arrive on average faster than they can be processed." />
      <item value="&lt;li&gt; &lt;em&gt; Direct handoffs.&lt;em&gt; A good default choice for a work queue is a {@link SynchronousQueue} that hands off tasks to threads without otherwise holding them. Here, an attempt to queue a task will fail if no threads are immediately available to run it, so a new thread will be constructed. This policy avoids lockups when handling sets of requests that might have internal dependencies. Direct handoffs generally require unbounded maximumPoolSizes to avoid rejection of new submitted tasks. This in turn admits the possibility of unbounded thread growth when commands continue to arrive on average faster than they can be processed." />
      <item value="avoid" />
      <item value="Direct handoffs" />
      <item value="handoffs" />
      <item value="general" />
      <item value="If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected" />
      <item value="If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing" />
      <item value="If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread." />
      <item value="Constraints" />
      <item value="Bean Validation 1.1 close() method available?" />
      <item value="Inner class to avoid a hard-coded Hibernate Validator 4.3 dependency." />
      <item value="Resolvers" />
      <item value="Provided" />
      <item value="convert" />
      <item value="Invoked after a value is resolved." />
      <item value="considered" />
      <item value="0 is considered as an invalid value" />
      <item value="positive" />
      <item value="strictly" />
      <item value="审核" />
      <item value="Delegates" />
      <item value="internal" />
      <item value="character" />
      <item value="Writes a sub array as a sequence of bytes." />
      <item value="Force all system buffers to synchronize with the underlying device. This method returns after all modified data and attributes of this FileDescriptor have been written to the relevant device(s). In particular, if this FileDescriptor refers to a physical storage medium, such as a file in a file system, sync will not return until all in-memory modified copies of buffers associated with this FileDesecriptor have been written to the physical medium." />
      <item value="Forces any changes made to this buffer's content to be written to the storage device containing the mapped file." />
      <item value="associated" />
      <item value="descriptor" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="253" />
        <entry key="ENGLISH" value="254" />
        <entry key="GERMAN" value="2" />
        <entry key="GUJARATI" value="1" />
        <entry key="GALICIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1620958800575" />
  </component>
</application>